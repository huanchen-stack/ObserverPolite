if task.Resp != nil {
		dbDoc.StatusCode = task.Resp.StatusCode
		dbDoc.RedirectChain = task.RedirectChain
		if len(dbDoc.RedirectChain) != 0 { // src -> dst change summary
			dst := dbDoc.RedirectChain[len(dbDoc.RedirectChain)-1]
			dstL := strings.Split(dst, " ")
			dstURL := dstL[len(dstL)-1]
			dstParsed, err := url.Parse(dstURL)
			if err != nil {
				fmt.Println("do something") //TODO: fix this
			}
			oriParsed, err := url.Parse(dbDoc.URL)
			if err != nil {
				fmt.Println("do something") //TODO: fix this
			}
			dbDoc.ChangeSummary = append(dbDoc.ChangeSummary, oriParsed.Scheme != dstParsed.Scheme)
			dbDoc.ChangeSummary = append(dbDoc.ChangeSummary, oriParsed.Hostname() != dstParsed.Hostname())
			dbDoc.ChangeSummary = append(dbDoc.ChangeSummary, oriParsed.Path != dstParsed.Path)
			dbDoc.ChangeSummary = append(dbDoc.ChangeSummary, oriParsed.RawQuery != dstParsed.RawQuery)
		}
	}
	if task.Err != nil {
		dbDoc.Err = task.Err.Error()
	}
	if task.AutoRetryHTTPS != nil && task.AutoRetryHTTPS.Retried {
		dbDoc.Retried = task.AutoRetryHTTPS.Retried
		if task.AutoRetryHTTPS.Resp != nil {
			dbDoc.RetriedStatusCode = task.AutoRetryHTTPS.Resp.StatusCode
			dbDoc.RetriedRedirectChain = task.AutoRetryHTTPS.RedirectChain
		}
		if task.AutoRetryHTTPS.Err != nil {
			dbDoc.RetriedErr = (*task.AutoRetryHTTPS).Err.Error()
		}
	}


func ScheduleTasks(tasks []Task) [][][]*Task {
	//	1. Maintain a domain map
	domainMap := make(map[string][]*Task)
	for i, task := range tasks {
		domainMap[task.Hostname] = append(domainMap[task.Hostname], &tasks[i])
	}
	//	2. Subgroups
	var subGroups [][][]*Task
	var tempGroups [][]*Task
	var groupLen int
	for _, taskList := range domainMap {
		listLen := len(taskList)
		if groupLen+listLen > GlobalConfig.WorkerStress {
			subGroups = append(subGroups, tempGroups)
			tempGroups = [][]*Task{}
			groupLen = 0
		}
		tempGroups = append(tempGroups, taskList)
		groupLen += listLen
	}
	if len(tempGroups) > 0 {
		subGroups = append(subGroups, tempGroups)
	}

	return subGroups

	////	3. Flat and Sort
	//var workerTaskList [][]*Task
	//for _, subGroup := range subGroups {
	//	var flatList []*Task
	//
	//	//	Use Naive sort for now; switch to k-merge if needed
	//	for _, taskList := range subGroup {
	//		N := float64(len(taskList))
	//		timeStep := GlobalConfig.ExpectedRuntime.Seconds() / N
	//		randStart := rand.Float64() * timeStep
	//		for _, task := range taskList {
	//			(*task).Schedule = time.Duration(randStart * float64(time.Second))
	//			flatList = append(flatList, task)
	//			randStart += timeStep
	//		}
	//	}
	//	sort.Slice(flatList, func(i, j int) bool {
	//		return (*flatList[i]).Schedule.Seconds() < (*flatList[j]).Schedule.Seconds()
	//	})
	//
	//	workerTaskList = append(workerTaskList, flatList)
	//}

	//return workerTaskList
}
